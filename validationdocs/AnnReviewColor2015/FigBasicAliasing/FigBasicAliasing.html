
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>FigBasicAliasing</title><meta name="generator" content="MATLAB 8.4"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2015-08-03"><meta name="DC.source" content="FigBasicAliasing.m"><style type="text/css">
html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,sub,sup,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}

html { min-height:100%; margin-bottom:1px; }
html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }
html body td { vertical-align:top; text-align:left; }

h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }
h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }
h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }

a { color:#005fce; text-decoration:none; }
a:hover { color:#005fce; text-decoration:underline; }
a:visited { color:#004aa0; text-decoration:none; }

p { padding:0px; margin:0px 0px 20px; }
img { padding:0px; margin:0px 0px 20px; border:none; }
p img, pre img, tt img, li img, h1 img, h2 img { margin-bottom:0px; } 

ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }
ul li { padding:0px; margin:0px 0px 7px 0px; }
ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }
ul li ol li { list-style:decimal; }
ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }
ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }
ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }
ol li ol li { list-style-type:lower-alpha; }
ol li ul { padding-top:7px; }
ol li ul li { list-style:square; }

.content { font-size:1.2em; line-height:140%; padding: 20px; }

pre, code { font-size:12px; }
tt { font-size: 1.2em; }
pre { margin:0px 0px 20px; }
pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }
pre.error { color:red; }

@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }

span.keyword { color:#0000FF }
span.comment { color:#228B22 }
span.string { color:#A020F0 }
span.untermstring { color:#B20000 }
span.syscmd { color:#B28C00 }

.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
.footer p { margin:0px; }
.footer a { color:#878787; }
.footer a:hover { color:#878787; text-decoration:underline; }
.footer a:visited { color:#878787; }

table th { padding:7px 5px; text-align:left; vertical-align:middle; border: 1px solid #d6d4d4; font-weight:bold; }
table td { padding:7px 5px; text-align:left; vertical-align:top; border:1px solid #d6d4d4; }





  </style></head><body><div class="content"><h2>Contents</h2><div><ul><li><a href="#2">Clear, define, etc.</a></li><li><a href="#3">Hello</a></li><li><a href="#4">Supress irritating warnings</a></li><li><a href="#6">Frozen noise, so that we can validate OK</a></li><li><a href="#7">Figure parameters</a></li><li><a href="#8">Compute parameters</a></li><li><a href="#9">Set up output names</a></li><li><a href="#10">Color matching functions</a></li><li><a href="#11">Set up optical image</a></li><li><a href="#12">Set up sensor</a></li><li><a href="#13">Create the scene</a></li><li><a href="#14">Optional.  Muck with photons to make a cone isolationg modulation.</a></li><li><a href="#15">Look at scene</a></li><li><a href="#16">Render the scene as sRGB</a></li><li><a href="#17">Compute optical image</a></li><li><a href="#18">Compare actual and desired spectral modulations</a></li><li><a href="#19">Render the oi as sRGB</a></li><li><a href="#20">Make sensor image</a></li><li><a href="#21">Demosaic</a></li><li><a href="#22">Isetbio cone demosaicing</a></li><li><a href="#23">Freeman method demosaicing</a></li><li><a href="#25">Restore warning state</a></li><li><a href="#26">Rethrow error</a></li></ul></div><pre class="codeinput"><span class="keyword">function</span> varargout = FigBasicAliasing(varargin)
<span class="comment">%</span>
<span class="comment">% Use linear interpolation to compute aliases for gratings.</span>
<span class="comment">%</span>
<span class="comment">% This has a number of parameters.  To produce the S cone alias pair</span>
<span class="comment">% for Figure 4 of the Annual Review paper, set</span>
<span class="comment">%   EXTRA_CHECKS = 1;</span>
<span class="comment">%   sceneDegrees = 3;</span>
<span class="comment">%   extractDegrees = 1;</span>
<span class="comment">%   SONLY = 1;</span>
<span class="comment">%   gratingCPD = 12;</span>
<span class="comment">%   desiredSContrast = 0.75;</span>
<span class="comment">%   SCALESRGBMethod = 1;</span>
<span class="comment">% Then use sRGBOptics_12cpd_noblur_sConeMod_75.tiff as the stimulus image</span>
<span class="comment">% and sRGBInterp_12cpd_noblur_sConeMod_75.tiff as the alias of the stimulus</span>
<span class="comment">% image.  These two iamges correspond to the same FOV in degrees but a</span>
<span class="comment">% different size in pixels.  That makes sense, as no effort was made to</span>
<span class="comment">% match pixels per degree in the scene to cones per degree in the sensor.</span>
<span class="comment">%</span>
<span class="comment">% There are some fussy things in this script.</span>
<span class="comment">%</span>
<span class="comment">% 1) If you run an S-cone isolating modulation through the optics with</span>
<span class="comment">% chromatic aberration, it doesn't isolate the S-cones any more by the time</span>
<span class="comment">% it reaches the retina.  The easiest way to deal with this for purposes of</span>
<span class="comment">% making figures is to make figures that don't include the optics.  But,</span>
<span class="comment">% the code will recompute the modulation so as to silence the S-scones if</span>
<span class="comment">% you ask it to.</span>
<span class="comment">%</span>
<span class="comment">% 2) I originally wrote this with the demosaicing done locally.  Now that</span>
<span class="comment">% functionality is ISETBIO, so this also calls the ISETBIO method.  I spent</span>
<span class="comment">% a lot of time trying to track down why the sRGB renderings done the two</span>
<span class="comment">% ways were different.  Turns out it has to do with where you clip and</span>
<span class="comment">% where you scale, and in what order.  Under most circumstances this</span>
<span class="comment">% doesn't matter, but if you have a lot of ringing from your</span>
<span class="comment">% interpolation, then the image your rendering has out of gamut pixels and</span>
<span class="comment">% then it matters.  Although most of the checks implemented here do check</span>
<span class="comment">% out, I left them in when you set EXTRA_CHECKS = 1.  Perhaps instructive</span>
<span class="comment">% some day when something else breaks.</span>
<span class="comment">%</span>
<span class="comment">% 3) It is fussy how to compare renderings across scenes, optical images,</span>
<span class="comment">% and sRGB images obtained from cones.  That is because the units aren't</span>
<span class="comment">% easily compared across these levels.  You could track the scale factors</span>
<span class="comment">% in the forward direction and then apply them in the reverse direction, so</span>
<span class="comment">% that (say), the optical image and demosaic'd XYZ images were referred</span>
<span class="comment">% back out to scene radiance by the appropriate scale factors.  I didn't do</span>
<span class="comment">% that because, well, life is short.  What I did do is have an option to</span>
<span class="comment">% render each SRGB image by setting its mean to 0.5 in the SRGB primary</span>
<span class="comment">% space.  This makes the scale nicely comparable for the figures I am</span>
<span class="comment">% currently interested in using.  It might not always work well, though.</span>
<span class="comment">% To get this behavior, set both EXTRA_CHECKS = 1and SCALESRGBMethod = 1.</span>
<span class="comment">%</span>
<span class="comment">% 4) Also note that there is some fussing of spatial scale that needs to</span>
<span class="comment">% happen to make the fov of the scene and optical images equal to that of</span>
<span class="comment">% the sensor image.  This results in the pixel resolutoin being different</span>
<span class="comment">% between the two representations.  This could probably be fixed up if one</span>
<span class="comment">% thought through the pixels per degree parameter in the original scene</span>
<span class="comment">% specification, which I didn't.  If one fixed this up, then one could in</span>
<span class="comment">% turn push the final alias back through the simulation chain and verify</span>
<span class="comment">% that it really was an alias by comparing the cone isomerization rates</span>
<span class="comment">% directly.</span>
<span class="comment">%</span>
<span class="comment">% It is possible we should push the scaling method as an option into the</span>
<span class="comment">% ISETBIO sensor demosaicing routine.  Or, track the scale factors.  What I</span>
<span class="comment">% do find is that the ISETBIO method of rendering produced strange results</span>
<span class="comment">% after demosaicing when there was considerable aliaising.</span>
<span class="comment">%</span>
<span class="comment">% 3/23/15   dhb  Wrote it.</span>
<span class="comment">% 6/29/15 dhb   Fix way we set up coneP to be more robust --  old less robust code got broken</span>
<span class="comment">%               by some lower level change.</span>

varargout = UnitTest.runValidationRun(@ValidationFunction, nargout, varargin);
<span class="keyword">end</span>

<span class="keyword">function</span> ValidationFunction(runTimeParams)
</pre><h2>Clear, define, etc.<a name="2"></a></h2><pre class="codeinput">ieInit;
</pre><h2>Hello<a name="3"></a></h2><pre class="codeinput">UnitTest.validationRecord(<span class="string">'SIMPLE_MESSAGE'</span>, sprintf(<span class="string">'%s'</span>,mfilename));
outputDir = sprintf(<span class="string">'%s_Output'</span>,mfilename);
<span class="keyword">if</span> (~exist(outputDir,<span class="string">'dir'</span>))
    mkdir(outputDir);
<span class="keyword">end</span>
</pre><h2>Supress irritating warnings<a name="4"></a></h2><pre class="codeinput">warnS = warning(<span class="string">'off'</span>,<span class="string">'images:initSize:adjustingMag'</span>);
<span class="keyword">try</span>
</pre><h2>Frozen noise, so that we can validate OK<a name="6"></a></h2><pre class="codeinput">    randomSeedValue = 26;
    rng(randomSeedValue);
</pre><h2>Figure parameters<a name="7"></a></h2><pre class="codeinput">    curDir = pwd;
    masterFigParamsDir = getpref(<span class="string">'bfScripts'</span>,<span class="string">'masterFigParamsDir'</span>);
    cd(masterFigParamsDir);
    figParams = MasterFigParams;
    cd(curDir);
    <span class="keyword">if</span> (exist(<span class="string">'../SecondaryFigParams'</span>,<span class="string">'file'</span>))
        cd <span class="string">..</span>
        figParams = SecondaryFigParams(figParams);
        cd(curDir);
    <span class="keyword">end</span>
    figParams.resizeScale = 1;
    UnitTest.validationData(<span class="string">'figParams'</span>, figParams);
</pre><h2>Compute parameters<a name="8"></a></h2><p>You can set these to do whatever you feel like</p><pre class="codeinput">    <span class="keyword">if</span> (runTimeParams.inStandAloneMode)
        EXTRA_CHECKS = 1;
        sceneDegrees = 3;
        extractDegrees = 1;
        DELTAFCNOPTICS = 1;
        SONLY = 1;
        gratingCpd = 12;
        desiredSContrast = 0.75;
        SCALESRGBMethod = 1;
        <span class="comment">% This branch is executed when you run from a validation script, and</span>
        <span class="comment">% should be left alone so that the parameters at runtime match those used</span>
        <span class="comment">% when the validation data were stored.</span>
    <span class="keyword">else</span>
        EXTRA_CHECKS = 1;
        sceneDegrees = 3;
        extractDegrees = 1;
        DELTAFCNOPTICS = 1;
        SONLY = 1;
        gratingCpd = 12;
        desiredSContrast = 0.75;
        SCALESRGBMethod = 1;
    <span class="keyword">end</span>
</pre><h2>Set up output names<a name="9"></a></h2><pre class="codeinput">    <span class="keyword">if</span> (DELTAFCNOPTICS)
        opticsStr = <span class="string">'noblur'</span>;
    <span class="keyword">else</span>
        opticsStr = <span class="string">'blur'</span>;
    <span class="keyword">end</span>
    <span class="keyword">if</span> (SONLY)
        sConeStr = [<span class="string">'sConeMod_'</span> num2str(round(100*desiredSContrast))];
    <span class="keyword">else</span>
        sConeStr = <span class="string">'achromMod'</span>;
    <span class="keyword">end</span>
    outputSuffix = sprintf(<span class="string">'_%dcpd_%s_%s'</span>,gratingCpd,opticsStr,sConeStr);
</pre><h2>Color matching functions<a name="10"></a></h2><pre class="codeinput">    S = [400 10 31];
    wls = SToWls(S);
    load(<span class="string">'T_xyz1931'</span>);
    T_xyz = SplineCmf(S_xyz1931,T_xyz1931,S);
    UnitTest.validationData(<span class="string">'S'</span>, S);
    UnitTest.validationData(<span class="string">'T_xyz'</span>, T_xyz);
</pre><h2>Set up optical image<a name="11"></a></h2><p>Do this early so we have the OTF when we need it.</p><pre class="codeinput">    oi = oiCreate(<span class="string">'human'</span>);
    oi = opticsSet(oi,<span class="string">'off axis method'</span>,<span class="string">'skip'</span>);

    <span class="comment">% Allow delta function optics</span>
    <span class="keyword">if</span> (DELTAFCNOPTICS)
        <span class="comment">%oi = oiSet(oi,'optics model','skip');</span>
        <span class="comment">% Kluge below, using 'skip seems cleaner</span>
        <span class="comment">%</span>
        <span class="comment">% Replace OTF with ones to get delta function optics</span>
        <span class="comment">% But, it seems to work just right.</span>
        optics = oiGet(oi,<span class="string">'optics'</span>);
        OTFData = opticsGet(optics,<span class="string">'otfdata'</span>);
        OTFDeltaData = ones(size(OTFData));
        optics = opticsSet(optics,<span class="string">'otfdata'</span>,OTFDeltaData);
        oi = oiSet(oi,<span class="string">'optics'</span>,optics);
    <span class="keyword">end</span>
</pre><h2>Set up sensor<a name="12"></a></h2><p>Do this early to get cone spectral sensitivities</p><p>The isetbio cone default is for 200 linear cones per degree in the fovea. This seems high for the central 1 degree overall, but might be correct right at the center.  So we adjust via pixel size.</p><p>For convenience, we normalize the energy unit fundamentals to a max of 1. This is because we aren't going to try to get the units right in the inverse transform from isomerization to XYZ, below.</p><pre class="codeinput">    coneP = coneCreate(<span class="string">'human'</span>);
    coneP = coneSet(coneP,<span class="string">'spatial density'</span>,[0.0 0.625 0.325 .05]);
    sensor = sensorCreate(<span class="string">'human'</span>,[],coneP);
    sensor = sensorSet(sensor, <span class="string">'noise flag'</span>, 0);
    sensor = sensorSet(sensor,<span class="string">'exp time'</span>,0.050);
    sensor = sensorSet(sensor,<span class="string">'rows'</span>,128);
    sensor = sensorSet(sensor,<span class="string">'cols'</span>,128);
    pixel = sensorGet(sensor,<span class="string">'pixel'</span>);
    pixel = pixelSet(pixel,<span class="string">'sizesamefillfactor'</span>,(200/120)*[1.5e-6 1.5e-6]);
    sensor = sensorSet(sensor,<span class="string">'pixel'</span>,pixel);
    T_conesQE = sensorGet(sensor,<span class="string">'spectral qe'</span>)';
    T_conesQE = T_conesQE(2:4,:);
    T_cones = EnergyToQuanta(wls,T_conesQE')';
    T_cones = T_cones/max(T_cones(:));
    UnitTest.validationData(<span class="string">'T_conesQE'</span>, T_conesQE);
    UnitTest.validationData(<span class="string">'T_cones'</span>, T_cones);
</pre><h2>Create the scene<a name="13"></a></h2><p>Choices are:   'harmonic'</p><p>Code for reading in a hyperspectral image here is in draft 0 of this code, but was removed from here just to keep things a bit simpler.</p><pre class="codeinput">    sceneType = <span class="string">'harmonic'</span>;
    <span class="keyword">switch</span> (sceneType)

        <span class="keyword">case</span> <span class="string">'harmonic'</span>
            <span class="comment">% Nice simple sinusoid.</span>
            parms.freq = round(gratingCpd*sceneDegrees); parms.contrast = 1; parms.ph = 0;
            parms.ang= 0; parms.row = 600; parms.col = 600; parms.GaborFlag=0;
            scene = sceneCreate(<span class="string">'harmonic'</span>,parms);
            scene = sceneSet(scene,<span class="string">'wave'</span>,wls');
            scene = sceneSet(scene,<span class="string">'fov'</span>,sceneDegrees);

        <span class="keyword">otherwise</span>
            error(<span class="string">'Unknown scene type'</span>);
    <span class="keyword">end</span>
</pre><h2>Optional.  Muck with photons to make a cone isolationg modulation.<a name="14"></a></h2><p>This is moderately straightforward if we don't worry about chromatic aberration, but gets trikier if we do. See below for method.</p><pre class="codeinput">    <span class="keyword">if</span> (SONLY)
        <span class="comment">% Get photon image from scene</span>
        scenePhotonsInitial = sceneGet(scene,<span class="string">'photons'</span>);

        <span class="comment">% Get mean level of the pattern, so that we can extract what</span>
        <span class="comment">% the modulation around this is.</span>
        <span class="keyword">for</span> w = 1:length(wls)
            temp = scenePhotonsInitial(:,:,w);
            backgroundSpectrum(w) = mean(temp(:));
        <span class="keyword">end</span>
        backgroundSpectrum = backgroundSpectrum';

        <span class="comment">% Define an identity basis and expresss the background with</span>
        <span class="comment">% respect to it</span>
        B_primary = 3*max(backgroundSpectrum(:))*eye(S(3));
        backgroundPrimary = B_primary\backgroundSpectrum;

        <span class="comment">% Use silent substitution toolbox machinery to find us a</span>
        <span class="comment">% spectral modulation that isolates the S cones.</span>
        whichPrimariesToPin = [1 size(B_primary,1)];
        primaryHeadRoom = 0.05;
        ambientSpd = zeros(size(B_primary,2),1);
        maxPowerDiff = 10000*max(backgroundSpectrum(:));
        whichReceptorsToTarget = [3];
        whichReceptorsToIgnore = [];
        whichReceptorsToMinimize = [];
        modulationPrimary = ReceptorIsolate(T_conesQE,whichReceptorsToTarget, whichReceptorsToIgnore, whichReceptorsToMinimize, <span class="keyword">...</span>
            B_primary, backgroundPrimary, backgroundPrimary, whichPrimariesToPin,<span class="keyword">...</span>
            primaryHeadRoom, maxPowerDiff, [], ambientSpd);

        <span class="comment">% Check that we got a sensible modulation with desired properties</span>
        backgroundReceptors = T_conesQE*(B_primary*backgroundPrimary + ambientSpd);
        modulationReceptors = T_conesQE*B_primary*(modulationPrimary - backgroundPrimary);
        contrastReceptors = modulationReceptors ./ backgroundReceptors;
        fprintf(<span class="string">'Maximized contrasts\n'</span>);
        <span class="keyword">for</span> n = 1:size(T_conesQE,1)
            fprintf(<span class="string">'\tPre-blur unmodified spectra, cone class %d contrast = %0.4f\n'</span>,n,contrastReceptors(n));
        <span class="keyword">end</span>
        modSpecFig = figure; clf; hold <span class="string">on</span>
        plot(wls,modulationPrimary,<span class="string">'r'</span>);
        plot(wls,backgroundPrimary,<span class="string">'k'</span>);
        ylim([0 1]);

        <span class="comment">% Muck with the photons in the scene to make it the desired</span>
        <span class="comment">% spectral modulation.  We also adjust maximized contrast here</span>
        <span class="comment">% to give desired contrast.</span>
        modulationSpectrum = B_primary*(modulationPrimary - backgroundPrimary);
        modulationSpectrum = (desiredSContrast/contrastReceptors(3))*modulationSpectrum;
        modulationReceptors = T_conesQE*modulationSpectrum;
        contrastReceptors = modulationReceptors ./ backgroundReceptors;
        fprintf(<span class="string">'After contrast adjust\n'</span>);
        <span class="keyword">for</span> n = 1:size(T_conesQE,1)
            fprintf(<span class="string">'\tPre-blur unmodified spectra, cone class %d contrast = %0.4f\n'</span>,n,contrastReceptors(n));
        <span class="keyword">end</span>
        scenePhotons = zeros(size(scenePhotonsInitial));
        <span class="keyword">for</span> w = 1:length(wls)
            temp = scenePhotonsInitial(:,:,w);
            imageMean = mean(temp(:));
            modulation = temp-imageMean;
            modulation = modulation/max(modulation(:));
            modulation = modulation*modulationSpectrum(w);
            temp = imageMean+modulation;
            scenePhotons(:,:,w) = temp;
        <span class="keyword">end</span>
        scene = sceneSet(scene,<span class="string">'photons'</span>,scenePhotons);
        minPhotons = min(scenePhotons(:));
        maxPhotons = max(scenePhotons(:));
        fprintf(<span class="string">'Scene, min/max photons: %0.2g, %0.2g\n'</span>,minPhotons,maxPhotons);
    <span class="keyword">end</span>
</pre><pre class="codeoutput">Maximized contrasts
	Pre-blur unmodified spectra, cone class 1 contrast = -0.0000
	Pre-blur unmodified spectra, cone class 2 contrast = -0.0000
	Pre-blur unmodified spectra, cone class 3 contrast = 1.0000
After contrast adjust
	Pre-blur unmodified spectra, cone class 1 contrast = -0.0000
	Pre-blur unmodified spectra, cone class 2 contrast = -0.0000
	Pre-blur unmodified spectra, cone class 3 contrast = 0.7500
Scene, min/max photons: 5e+14, 7.2e+15
</pre><img vspace="5" hspace="5" src="FigBasicAliasing_01.png" alt=""> <h2>Look at scene<a name="15"></a></h2><pre class="codeinput">    vcAddAndSelectObject(scene); sceneWindow;
</pre><img vspace="5" hspace="5" src="FigBasicAliasing_02.png" alt=""> <h2>Render the scene as sRGB<a name="16"></a></h2><pre class="codeinput">    tempHyperspectralQuantal = scene.data.photons;
    [mScene,nScene,~] = size(tempHyperspectralQuantal);
    rowBorderScene = round((mScene - mScene*extractDegrees/sceneDegrees)/2);
    colBorderScene = round((nScene - nScene*extractDegrees/sceneDegrees)/2);
    tempHyperspectralEnergy = zeros(size(tempHyperspectralQuantal));
    <span class="keyword">for</span> w = 1:length(wls)
        temp = tempHyperspectralQuantal(:,:,w);
        temp = temp(:);
        tempQuantal = QuantaToEnergy(wls(w),temp);
        tempHyperspectralEnergy(:,:,w) = reshape(tempQuantal,mScene,nScene);
    <span class="keyword">end</span>
    sensorXYZImage = zeros(mScene,nScene,3);
    <span class="keyword">for</span> i = 1:length(wls)
        sensorXYZImage(:,:,1) = sensorXYZImage(:,:,1) + T_xyz(1,i)*tempHyperspectralEnergy(:,:,i);
        sensorXYZImage(:,:,2) = sensorXYZImage(:,:,2) + T_xyz(2,i)*tempHyperspectralEnergy(:,:,i);
        sensorXYZImage(:,:,3) = sensorXYZImage(:,:,3) + T_xyz(3,i)*tempHyperspectralEnergy(:,:,i);
    <span class="keyword">end</span>
    [sceneXYZCal,nX,nY] = ImageToCalFormat(sensorXYZImage);
    sceneXYZCal = sceneXYZCal/max(sceneXYZCal(:));
    srgbPrimaryCal = XYZToSRGBPrimary(sceneXYZCal);
    sRGBMeanScaleFactor = nanmean(srgbPrimaryCal(:));
    sRGBCal = SRGBGammaCorrect(0.5*srgbPrimaryCal/sRGBMeanScaleFactor,0);
    sceneSRGBImage = uint8(CalFormatToImage(sRGBCal,nX,nY));
    figure; clf;
    imshow(sceneSRGBImage);
    imwrite(sceneSRGBImage(rowBorderScene:end-rowBorderScene,colBorderScene:end-colBorderScene,:),fullfile(outputDir,[mfilename <span class="string">'_'</span> <span class="string">'sRGBScene'</span> outputSuffix <span class="string">'.'</span> figParams.imType]),figParams.imType);
    UnitTest.validationData(<span class="string">'sceneSRBImage'</span>, sceneSRGBImage);
</pre><img vspace="5" hspace="5" src="FigBasicAliasing_03.png" alt=""> <h2>Compute optical image<a name="17"></a></h2><pre class="codeinput">    oi = oiCompute(oi,scene);
    tempHyperspectralQuantal = oiGet(oi,<span class="string">'photons'</span>);
    [mOi,nOi,~] = size(tempHyperspectralQuantal);
</pre><h2>Compare actual and desired spectral modulations<a name="18"></a></h2><p>Fix up as necessary.  This step is necessary for the S-cone isolating modulation, because we want it to be S-cone isolating on the retina, and chromatic aberration will modify the initially presented stimulus.</p><p>This counts on the fact that we have a grating stimulus, so that the effect of blurring is more or less the same at all pixels up to a scale factor.</p><p>I also tried handling this by using the OTF directly, but it didn't work very well.  It may be that I didn't fully debug things, but I suspect that comptuational splatter was screwing me up -- given the frequency sampling, an arbitrary frequency grating will not have its power all at one sf in the frequency domain and that makes things a bit tricky.</p><pre class="codeinput">    <span class="keyword">if</span> (SONLY)
        <span class="keyword">for</span> w = 1:length(wls)
            temp = tempHyperspectralQuantal(:,:,w);
            backgroundSpectrumActual(w) = mean(temp(:));
        <span class="keyword">end</span>
        backgroundSpectrumActual = backgroundSpectrumActual';
        pixelSpectrumActual = squeeze(tempHyperspectralQuantal(round(mOi/2),round(nOi/2),:));
        modulationSpectrumActual = pixelSpectrumActual-backgroundSpectrumActual;
        modulationSpectrumCompare = modulationSpectrum*(modulationSpectrum\modulationSpectrumActual);
        figure; hold <span class="string">on</span>
        plot(wls,backgroundSpectrumActual,<span class="string">'k'</span>);
        plot(wls,modulationSpectrumCompare+backgroundSpectrumActual,<span class="string">'r'</span>,<span class="string">'LineWidth'</span>,2);
        plot(wls,modulationSpectrumActual+backgroundSpectrumActual,<span class="string">'g'</span>);

        <span class="comment">% Fix up relative modulation spectrum</span>
        <span class="comment">%</span>
        <span class="comment">% First get OTF, dealing with the divide by zero problem</span>
        index = find(modulationSpectrum ~= 0);
        effectiveOTFRelative = zeros(size(modulationSpectrum));
        effectiveOTFRelative(index) = modulationSpectrumActual(index) ./ modulationSpectrumCompare(index);
        index1 = find(modulationSpectrum == 0);
        effectiveOTFRelative(index1) = mean(effectiveOTFRelative(index));

        <span class="comment">% Precompensate modulation spectrum and scale to match</span>
        <span class="comment">% original scene modulation</span>
        newModulationSpectrumRelative = modulationSpectrum ./ effectiveOTFRelative;
        newModulationSpectrum = newModulationSpectrumRelative*(newModulationSpectrumRelative\modulationSpectrum);
        figure; clf; hold <span class="string">on</span>
        plot(wls,backgroundSpectrum,<span class="string">'k'</span>);
        plot(wls,modulationSpectrum+backgroundSpectrum,<span class="string">'r'</span>);
        plot(wls,newModulationSpectrum+backgroundSpectrum,<span class="string">'g'</span>);

        <span class="comment">% Report the cone contrasts pre blur for this modified spectrum, just</span>
        <span class="comment">% as a reality check.</span>
        backgroundReceptors = T_conesQE*backgroundSpectrum;
        modulationReceptors = T_conesQE*newModulationSpectrum;
        contrastReceptors = modulationReceptors ./ backgroundReceptors;
        fprintf(<span class="string">'Contrasts for modified spectra\n'</span>);
        <span class="keyword">for</span> n = 1:size(T_conesQE,1)
            fprintf(<span class="string">'\tPre-blur modified spectra, cone class %d contrast = %0.4f\n'</span>,n,contrastReceptors(n));
        <span class="keyword">end</span>

        <span class="comment">% Rewrite the scene with new modulation</span>
        newScenePhotons = zeros(size(scenePhotonsInitial));
        <span class="keyword">for</span> w = 1:length(wls)
            temp = scenePhotonsInitial(:,:,w);
            imageMean = mean(temp(:));
            modulation = temp-imageMean;
            modulation = modulation/max(modulation(:));
            modulation = modulation*newModulationSpectrum(w);
            temp = imageMean+modulation;
            newScenePhotons(:,:,w) = temp;
        <span class="keyword">end</span>
        scene = sceneSet(scene,<span class="string">'photons'</span>,newScenePhotons);
        vcAddAndSelectObject(scene); sceneWindow;

        <span class="comment">% Check</span>
        newMinPhotons = min(newScenePhotons(:));
        newMaxPhotons = max(newScenePhotons(:));
        fprintf(<span class="string">'Modified scene, min/max photons: %0.2g, %0.2g\n'</span>,newMinPhotons,newMaxPhotons);

        <span class="comment">% Recompute the optical image and hope for the best</span>
        oi = oiCompute(oi,scene);
    <span class="keyword">end</span>
    vcAddAndSelectObject(oi); oiWindow;
    UnitTest.validationData(<span class="string">'scene'</span>, scene);
    UnitTest.validationData(<span class="string">'oi'</span>, oi);
</pre><pre class="codeoutput">Contrasts for modified spectra
	Pre-blur modified spectra, cone class 1 contrast = -0.0010
	Pre-blur modified spectra, cone class 2 contrast = -0.0010
	Pre-blur modified spectra, cone class 3 contrast = 0.7499
Modified scene, min/max photons: 5e+14, 7.2e+15
</pre><img vspace="5" hspace="5" src="FigBasicAliasing_04.png" alt=""> <img vspace="5" hspace="5" src="FigBasicAliasing_05.png" alt=""> <img vspace="5" hspace="5" src="FigBasicAliasing_06.png" alt=""> <img vspace="5" hspace="5" src="FigBasicAliasing_07.png" alt=""> <h2>Render the oi as sRGB<a name="19"></a></h2><pre class="codeinput">    rowExtraBorderOi = round((mOi-mScene)/2);
    colExtraBorderOI = round((nOi-nScene)/2);
    tempHyperspectralEnergy = zeros(size(tempHyperspectralQuantal));
    <span class="keyword">for</span> w = 1:length(wls)
        temp = tempHyperspectralQuantal(:,:,w);
        temp = temp(:);
        tempQuantal = QuantaToEnergy(wls(w),temp);
        tempHyperspectralEnergy(:,:,w) = reshape(tempQuantal,mOi,nOi);
    <span class="keyword">end</span>
    oiXYZImage = zeros(mOi,nOi,3);
    <span class="keyword">for</span> i = 1:length(wls)
        oiXYZImage(:,:,1) = oiXYZImage(:,:,1) + T_xyz(1,i)*tempHyperspectralEnergy(:,:,i);
        oiXYZImage(:,:,2) = oiXYZImage(:,:,2) + T_xyz(2,i)*tempHyperspectralEnergy(:,:,i);
        oiXYZImage(:,:,3) = oiXYZImage(:,:,3) + T_xyz(3,i)*tempHyperspectralEnergy(:,:,i);
    <span class="keyword">end</span>
    [oiXYZCal,nX,nY] = ImageToCalFormat(oiXYZImage);
    oiXYZCal = oiXYZCal/max(oiXYZCal(:));
    srgbPrimaryCal = XYZToSRGBPrimary(oiXYZCal);
    sRGBMeanScaleFactor = nanmean(srgbPrimaryCal(:));
    sRGBCal = SRGBGammaCorrect(0.5*srgbPrimaryCal/sRGBMeanScaleFactor,0);
    oiSRGBImage = uint8(CalFormatToImage(sRGBCal,nX,nY));
    figure; clf;
    imshow(oiSRGBImage);
    imwrite(oiSRGBImage(rowExtraBorderOi+rowBorderScene:end-rowBorderScene-rowExtraBorderOi,colExtraBorderOI+colBorderScene:end-colBorderScene-colExtraBorderOI,:), <span class="keyword">...</span>
        fullfile(outputDir,[mfilename <span class="string">'_'</span> <span class="string">'sRGBOptics'</span> outputSuffix <span class="string">'.'</span> figParams.imType]),figParams.imType);
    UnitTest.validationData(<span class="string">'oiSRGBImage'</span>, oiSRGBImage);
</pre><img vspace="5" hspace="5" src="FigBasicAliasing_08.png" alt=""> <h2>Make sensor image<a name="20"></a></h2><pre class="codeinput">    [sensor, ~] = sensorSetSizeToFOV(sensor,sceneDegrees,scene,oi);
    sensor = sensorCompute(sensor,oi);
    vcAddAndSelectObject(sensor); sensorWindow(<span class="string">'scale'</span>,1);
    UnitTest.validationData(<span class="string">'sensor'</span>, sensor);
</pre><img vspace="5" hspace="5" src="FigBasicAliasing_09.png" alt=""> <h2>Demosaic<a name="21"></a></h2><pre class="codeinput">    cfa = sensorGet(sensor,<span class="string">'cfa'</span>);
    mosaicImage = sensorGet(sensor,<span class="string">'photons'</span>);
    [imageHeight,imageWidth] = size(mosaicImage);

    <span class="comment">% Use griddata to do separate submosaic interpolation</span>
    <span class="comment">%</span>
    <span class="comment">% Be sure to deal with isetbio's indexing that 1 -&gt; black.</span>
    method = <span class="string">'linear'</span>;
    [X,Y] = meshgrid(1:imageWidth,1:imageHeight);
    nCones = zeros(size(T_conesQE,1),1);
    <span class="keyword">for</span> n = 1:size(T_conesQE,1)
        index = find(cfa.pattern == n+1);
        nCones(n) = length(index(:));
        x1 = X(index);
        y1 = Y(index);
        z1 = mosaicImage(index);
        interpImageLMS(:,:,n) = griddata(x1,y1,z1,X,Y,method);
        fprintf(<span class="string">'Cone class %d, min = %0.2g, max = %0.2g\n'</span>,n,min(z1(:)),max(z1(:)));
    <span class="keyword">end</span>
    <span class="keyword">for</span> n = 1:size(T_conesQE,1)
        fprintf(<span class="string">'Fraction cone class %d = %0.2f\n'</span>,n,nCones(n)/sum(nCones));
    <span class="keyword">end</span>
    fprintf(<span class="string">'Total number of cones %d, expected %d\n'</span>,sum(nCones),imageWidth*imageHeight);
    UnitTest.assertIsZero(sum(nCones)-imageWidth*imageHeight,<span class="string">'Difference from expected total number of cones'</span>,0);
    UnitTest.validationData(<span class="string">'interpImageLMS'</span>, interpImageLMS);

    <span class="comment">% Just checking.  T_cones ought to be proportional to T_cones_ss2, more or</span>
    <span class="comment">% less.  It is.  The small differenes are due to slightly different</span>
    <span class="comment">% tabulations of the Stockman-Sharpe fundamentals in PTB and ISETBIO.</span>
    <span class="keyword">if</span> (EXTRA_CHECKS)
        load <span class="string">T_cones_ss2</span>
        figure; clf; hold <span class="string">on</span>
        plot(wls,T_cones',<span class="string">'r'</span>);
        plot(wls,T_cones(1,:)'/max(T_cones(1,:)),<span class="string">'b'</span>);
        plot(wls,T_cones(2,:)'/max(T_cones(2,:)),<span class="string">'b'</span>);
        plot(wls,T_cones(3,:)'/max(T_cones(3,:)),<span class="string">'b'</span>);
        plot(SToWls(S_cones_ss2),T_cones_ss2',<span class="string">'g'</span>);
        xlabel(<span class="string">'Wavelength (nm)'</span>);
        ylabel(<span class="string">'Sensitivity (energy units)'</span>);
        title(<span class="string">'Check on cone sensitivities'</span>);
        clear <span class="string">T_cones_ss2</span> <span class="string">S_cones_ss2</span>
    <span class="keyword">end</span>

    <span class="comment">% Render by converting from LMS to sRGB.</span>
    <span class="comment">%</span>
    <span class="comment">% Start by finding matrix that takes LMS to XYZ.  We use</span>
    <span class="comment">% T_cones in the conversion, because T_cones is in energy</span>
    <span class="comment">% units but scaled consistently with the quantal efficiencies</span>
    <span class="comment">% used to compute the isomerizations.</span>
    <span class="comment">%</span>
    <span class="comment">% The absolute units here are not correct, because we'd have to</span>
    <span class="comment">% back from isomerization out to cd/m2 in order to get them correct,</span>
    <span class="comment">% and that would be a pain.</span>
    M_LMSToXYZ = ((T_cones)'\(T_xyz'))';
    <span class="keyword">if</span> (EXTRA_CHECKS)
        T_xyzCheck = M_LMSToXYZ*T_cones;
        figure; clf; hold <span class="string">on</span>
        plot(wls,T_xyz',<span class="string">'k'</span>);
        plot(wls,T_xyzCheck',<span class="string">'r'</span>);
        xlabel(<span class="string">'Wavelength (nm)'</span>);
        ylabel(<span class="string">'XYZ'</span>);
        title(<span class="string">'LMS -&gt; XYZ Check'</span>);
    <span class="keyword">end</span>

    <span class="comment">% Here are the xform matrices that sensorDemosaicCones is using,</span>
    <span class="comment">% transposed for PTB format.</span>
    <span class="keyword">if</span> (EXTRA_CHECKS)
        M_lms2xyz = [1.7896   -1.4694    2.1504
            0.6079    0.4651   -0.2236
            -0.0499    0.0923   10.6431];
        M_xyz2srgb = [3.2410   -1.5374   -0.4986
            -0.9692    1.8760    0.0416
            0.0556   -0.2040    1.0570];
    <span class="keyword">end</span>

    <span class="comment">% The exact order of clipping and scaling in the conversion from</span>
    <span class="comment">% XYZ to sRGB matters in some cases.  ISETBIO scales in XYZ by</span>
    <span class="comment">% the maximum Y value, then clips negative XYZ values, then converts</span>
    <span class="comment">% to SRGB primaries, and then clips to 0-1.  PTB does not touch the</span>
    <span class="comment">% XYZ values normally, and can either scale to max of 1 in SRGB primary</span>
    <span class="comment">% or clip, depending on how you call SRGBGammaCorrect.  Here I have</span>
    <span class="comment">% made the PTB behavior match the ISETBIO behavior by hand, depending on</span>
    <span class="comment">% the value of SCALESRGBMethod.</span>
    <span class="keyword">if</span> (EXTRA_CHECKS)
        [interpImageLMSCal,m,n] = ImageToCalFormat(interpImageLMS);
        interpImageXYZCal = M_LMSToXYZ*interpImageLMSCal;
        interpImageXYZCalCheck = M_lms2xyz*interpImageLMSCal;
        interpImageXYZCal = interpImageXYZCal/max(interpImageXYZCal(2,:));
        interpImageXYZCalCheck = interpImageXYZCalCheck/max(interpImageXYZCalCheck(2,:));
        <span class="keyword">if</span> (~SCALESRGBMethod)
            interpImageXYZCal(interpImageXYZCal &lt; 0) = 0;
            interpImageXYZCalCheck(interpImageXYZCalCheck &lt; 0) = 0;
        <span class="keyword">end</span>
        interpImageSRGBPrimaryCal = XYZToSRGBPrimary(interpImageXYZCal);
        interpImageSRGBPrimaryCalCheck = M_xyz2srgb*interpImageXYZCal;
        <span class="keyword">if</span> (SCALESRGBMethod)
            sRGBMeanScaleFactor = nanmean(interpImageSRGBPrimaryCal(:));
            interpImageSRGBCal = SRGBGammaCorrect(0.5*interpImageSRGBPrimaryCal/sRGBMeanScaleFactor,0);
        <span class="keyword">else</span>
            interpImageSRGBCal = SRGBGammaCorrect(interpImageSRGBPrimaryCal,0);
        <span class="keyword">end</span>
        interpImageSRGB = uint8(CalFormatToImage(interpImageSRGBCal,m,n));
        UnitTest.validationData(<span class="string">'interpImageSRGB'</span>, interpImageSRGB);
    <span class="keyword">end</span>

    <span class="comment">% This figure checks for consistency between two ways of computing some of</span>
    <span class="comment">% the relevant quantities</span>
    <span class="keyword">if</span> (EXTRA_CHECKS)
        figure; clf;
        subplot(1,2,1); hold <span class="string">on</span>
        plot(interpImageXYZCal(:),interpImageXYZCalCheck(:),<span class="string">'ro'</span>);
        plot([0 1],[0 1],<span class="string">'k'</span>);
        xlabel(<span class="string">'XYZ convert PTB'</span>);
        ylabel(<span class="string">'XYZ convert isetbio matrix'</span>);
        subplot(1,2,2); hold <span class="string">on</span>
        plot(interpImageSRGBPrimaryCal(:),interpImageSRGBPrimaryCalCheck(:),<span class="string">'ro'</span>);
        plot([-0.5 1.5],[-0.5 1.5],<span class="string">'k'</span>);
        axis([-0.5 1.5 -0.5 1.5]);
        xlabel(<span class="string">'sRGBPrimary convert PTB'</span>);
        ylabel(<span class="string">'sRGBPrimary convert isetbio matrix'</span>);
    <span class="keyword">end</span>
</pre><pre class="codeoutput">Cone class 1, min = 1.3e+03, max = 1.3e+03
Cone class 2, min = 9.5e+02, max = 9.6e+02
Cone class 3, min = 35, max = 2.4e+02
Fraction cone class 1 = 0.63
Fraction cone class 2 = 0.32
Fraction cone class 3 = 0.05
Total number of cones 130321, expected 130321
</pre><img vspace="5" hspace="5" src="FigBasicAliasing_10.png" alt=""> <img vspace="5" hspace="5" src="FigBasicAliasing_11.png" alt=""> <img vspace="5" hspace="5" src="FigBasicAliasing_12.png" alt=""> <h2>Isetbio cone demosaicing<a name="22"></a></h2><p>That's the way you do, get your money for nothing.</p><pre class="codeinput">    [isetbioInterpImageSRGB,isetbioInterpImageLMS] = sensorDemosaicCones(sensor,method);
    UnitTest.validationData(<span class="string">'isetbioInterpImageLMS'</span>, isetbioInterpImageLMS);
    UnitTest.validationData(<span class="string">'isetbioInterpImageSRGB'</span>, isetbioInterpImageSRGB);

    <span class="comment">% We can do the PTB SRGB method, which works better if there is masssive</span>
    <span class="comment">% ringing.</span>
    [mInterp,nInterp,~] = size(isetbioInterpImageSRGB);
    rowBorderInterp = round((mInterp-mInterp*extractDegrees/sceneDegrees)/2);
    colBorderInterp = round((nInterp-nInterp*extractDegrees/sceneDegrees)/2);
    figure; clf;
    <span class="keyword">if</span> (EXTRA_CHECKS &amp; SCALESRGBMethod)
        imshow(interpImageSRGB);
        title(<span class="string">'Linear interp SRGB'</span>);
        imwrite(interpImageSRGB(rowBorderInterp:end-rowBorderInterp,colBorderInterp:end-colBorderInterp,:),fullfile(outputDir,[mfilename <span class="string">'_'</span> <span class="string">'sRGBInterp'</span> outputSuffix <span class="string">'.'</span> figParams.imType]),figParams.imType);
    <span class="keyword">else</span>
        imshow(isetbioInterpImageSRGB);
        title(<span class="string">'Linear interp SRGB'</span>);
        imwrite(isetbioInterpImageSRGB(rowBorderInterp:end-rowBorderInterp,colBorderInterp:end-colBorderInterp,:),fullfile(outputDir,[mfilename <span class="string">'_'</span> <span class="string">'sRGBInterp'</span> outputSuffix <span class="string">'.'</span> figParams.imType]),figParams.imType);
    <span class="keyword">end</span>

    <span class="comment">% Compare with the local way</span>
    <span class="keyword">if</span> (EXTRA_CHECKS)
        figure; clf;
        subplot(1,2,1); hold <span class="string">on</span>;
        imshow(interpImageSRGB(rowBorderInterp:end-rowBorderInterp,colBorderInterp:end-colBorderInterp,:));
        title(<span class="string">'Local linear interp SRGB'</span>);
        subplot(1,2,2); hold <span class="string">on</span>;
        imshow(isetbioInterpImageSRGB(rowBorderInterp:end-rowBorderInterp,colBorderInterp:end-colBorderInterp,:));
        title(<span class="string">'ISETBIO linear interp SRGB'</span>);
        differenceInterpLMS = interpImageLMS(:) - isetbioInterpImageLMS(:);
        maxDifferenceLMS = max(abs(differenceInterpLMS));
        tolerance = 1e-17;
        UnitTest.assertIsZero(maxDifferenceLMS,<span class="string">'ISETBIO and local griddata difference'</span>,tolerance);
    <span class="keyword">end</span>
</pre><img vspace="5" hspace="5" src="FigBasicAliasing_13.png" alt=""> <img vspace="5" hspace="5" src="FigBasicAliasing_14.png" alt=""> <h2>Freeman method demosaicing<a name="23"></a></h2><p>I implemented this by and and then in ISETBIO</p><pre class="codeinput">    <span class="keyword">if</span> (EXTRA_CHECKS)
        masterSensor = 1;
        filterSize = 5;
        freemanInterpImageLMS = interpImageLMS;
        tempMaster = interpImageLMS(:,:,masterSensor);
        <span class="keyword">for</span> n = 1:3
            <span class="keyword">if</span> (n ~= masterSensor)
                diffImage = interpImageLMS(:,:,n) - tempMaster;
                diffImage = medfilt2(diffImage,[filterSize filterSize]);
                index = find(cfa.pattern ~= n+1);
                temp = interpImageLMS(:,:,n);
                temp(index) = diffImage(index) + tempMaster(index);
                freemanInterpImageLMS(:,:,n) = temp;
            <span class="keyword">end</span>
        <span class="keyword">end</span>

        [freemanInterpImageLMSCal,m,n] = ImageToCalFormat(freemanInterpImageLMS);
        freemanInterpImageXYZCal = M_LMSToXYZ*freemanInterpImageLMSCal;
        freemanInterpImageXYZCal = freemanInterpImageXYZCal/max(freemanInterpImageXYZCal(2,:));
        <span class="keyword">if</span> (~SCALESRGBMethod)
            freemanInterpImageXYZCal(freemanImageXYZCal &lt; 0) = 0;
        <span class="keyword">end</span>
        freemanInterpImageSRGBPrimayCal = XYZToSRGBPrimary(freemanInterpImageXYZCal);
        <span class="keyword">if</span> (SCALESRGBMethod)
            sRGBMeanScaleFactor = nanmean(freemanInterpImageSRGBPrimayCal(:));
            freemanInterpImageSRGBCal = SRGBGammaCorrect(0.5*interpImageSRGBPrimaryCal/sRGBMeanScaleFactor,0);
        <span class="keyword">else</span>
            freemanInterpImageSRGBCal = SRGBGammaCorrect(freemanInterpImageSRGBPrimayCal,0);
        <span class="keyword">end</span>
        freemanInterpImageSRGB = uint8(CalFormatToImage(freemanInterpImageSRGBCal,m,n));
        UnitTest.validationData(<span class="string">'freemanInterpImageLMS'</span>, freemanInterpImageLMS);
        UnitTest.validationData(<span class="string">'freemanInterpImageSRGB'</span>, freemanInterpImageSRGB);
    <span class="keyword">end</span>

    <span class="comment">% Now just do it in ISETBIO</span>
    [isetbioFreemanInterpImageSRGB,isetbioFreemanInterpImageLMS] = sensorDemosaicCones(sensor,<span class="string">'freeman'</span>);
    figure; clf;
    <span class="keyword">if</span> (EXTRA_CHECKS &amp; SCALESRGBMethod)
        imshow(freemanInterpImageSRGB);
        title(<span class="string">'Freeman interp SRGB'</span>);
        imwrite(freemanInterpImageSRGB(rowBorderInterp:end-rowBorderInterp,colBorderInterp:end-colBorderInterp,:),fullfile(outputDir,[mfilename <span class="string">'_'</span> <span class="string">'sRGBFreemanInterp'</span> outputSuffix <span class="string">'.'</span> figParams.imType]),figParams.imType);
    <span class="keyword">else</span>
        imshow(isetbioFreemanInterpImageSRGB);
        title(<span class="string">'Freeman interp SRGB'</span>);
        [mInterp,nInterp,~] = size(isetbioFreemanInterpImageSRGB);
        imwrite(isetbioFreemanInterpImageSRGB(rowBorderInterp:end-rowBorderInterp,colBorderInterp:end-colBorderInterp,:),fullfile(outputDir,[mfilename <span class="string">'_'</span> <span class="string">'sRGBFreemanInterp'</span> outputSuffix <span class="string">'.'</span> figParams.imType]),figParams.imType);
    <span class="keyword">end</span>
    UnitTest.validationData(<span class="string">'isetbioFreemanInterpImageLMS'</span>, isetbioFreemanInterpImageLMS);
    UnitTest.validationData(<span class="string">'isetbioFreemanInterpImageSRGB'</span>, isetbioFreemanInterpImageSRGB);

    <span class="comment">% Compare with the local way</span>
    <span class="keyword">if</span> (EXTRA_CHECKS)
        figure; clf;
        subplot(1,2,1); hold <span class="string">on</span>;
        imshow(isetbioFreemanInterpImageSRGB(rowBorderInterp:end-rowBorderInterp,colBorderInterp:end-colBorderInterp,:));
        title(<span class="string">'Local Freeman interp SRGB'</span>);
        subplot(1,2,2); hold <span class="string">on</span>;
        imshow(isetbioFreemanInterpImageSRGB(rowBorderInterp:end-rowBorderInterp,colBorderInterp:end-colBorderInterp,:));
        title(<span class="string">'ISETBIO Freeman interp SRGB'</span>);
        differenceFreemanLMS = interpImageLMS(:) - isetbioInterpImageLMS(:);
        maxDifferenceLMS = max(abs(differenceFreemanLMS));
        <span class="keyword">if</span> (maxDifferenceLMS ~= 0)
            fprintf(<span class="string">'WARNING: ISETBIO and local freeman interpolation do not agree\n'</span>);
        <span class="keyword">end</span>
    <span class="keyword">end</span>
</pre><pre class="codeinput"><span class="keyword">catch</span> err
</pre><h2>Restore warning state<a name="25"></a></h2><pre class="codeinput">    warning(warnS.state,warnS.identifier);
</pre><h2>Rethrow error<a name="26"></a></h2><pre class="codeinput">    rethrow(err);
</pre><pre class="codeinput"><span class="keyword">end</span>
</pre><img vspace="5" hspace="5" src="FigBasicAliasing_15.png" alt=""> <img vspace="5" hspace="5" src="FigBasicAliasing_16.png" alt=""> <pre class="codeinput"><span class="keyword">end</span>
</pre><p class="footer"><br><a href="http://www.mathworks.com/products/matlab/">Published with MATLAB&reg; R2014b</a><br></p></div><!--
##### SOURCE BEGIN #####
function varargout = FigBasicAliasing(varargin)
%
% Use linear interpolation to compute aliases for gratings.
%
% This has a number of parameters.  To produce the S cone alias pair
% for Figure 4 of the Annual Review paper, set
%   EXTRA_CHECKS = 1;
%   sceneDegrees = 3;
%   extractDegrees = 1;
%   SONLY = 1;
%   gratingCPD = 12;
%   desiredSContrast = 0.75;
%   SCALESRGBMethod = 1;
% Then use sRGBOptics_12cpd_noblur_sConeMod_75.tiff as the stimulus image
% and sRGBInterp_12cpd_noblur_sConeMod_75.tiff as the alias of the stimulus
% image.  These two iamges correspond to the same FOV in degrees but a
% different size in pixels.  That makes sense, as no effort was made to
% match pixels per degree in the scene to cones per degree in the sensor.
%
% There are some fussy things in this script.
%
% 1) If you run an S-cone isolating modulation through the optics with
% chromatic aberration, it doesn't isolate the S-cones any more by the time
% it reaches the retina.  The easiest way to deal with this for purposes of
% making figures is to make figures that don't include the optics.  But,
% the code will recompute the modulation so as to silence the S-scones if
% you ask it to.
%
% 2) I originally wrote this with the demosaicing done locally.  Now that
% functionality is ISETBIO, so this also calls the ISETBIO method.  I spent
% a lot of time trying to track down why the sRGB renderings done the two
% ways were different.  Turns out it has to do with where you clip and
% where you scale, and in what order.  Under most circumstances this
% doesn't matter, but if you have a lot of ringing from your
% interpolation, then the image your rendering has out of gamut pixels and
% then it matters.  Although most of the checks implemented here do check
% out, I left them in when you set EXTRA_CHECKS = 1.  Perhaps instructive
% some day when something else breaks.
%
% 3) It is fussy how to compare renderings across scenes, optical images,
% and sRGB images obtained from cones.  That is because the units aren't
% easily compared across these levels.  You could track the scale factors
% in the forward direction and then apply them in the reverse direction, so
% that (say), the optical image and demosaic'd XYZ images were referred
% back out to scene radiance by the appropriate scale factors.  I didn't do
% that because, well, life is short.  What I did do is have an option to
% render each SRGB image by setting its mean to 0.5 in the SRGB primary
% space.  This makes the scale nicely comparable for the figures I am
% currently interested in using.  It might not always work well, though.
% To get this behavior, set both EXTRA_CHECKS = 1and SCALESRGBMethod = 1.
%
% 4) Also note that there is some fussing of spatial scale that needs to
% happen to make the fov of the scene and optical images equal to that of
% the sensor image.  This results in the pixel resolutoin being different
% between the two representations.  This could probably be fixed up if one
% thought through the pixels per degree parameter in the original scene
% specification, which I didn't.  If one fixed this up, then one could in
% turn push the final alias back through the simulation chain and verify
% that it really was an alias by comparing the cone isomerization rates
% directly.
%
% It is possible we should push the scaling method as an option into the
% ISETBIO sensor demosaicing routine.  Or, track the scale factors.  What I
% do find is that the ISETBIO method of rendering produced strange results
% after demosaicing when there was considerable aliaising.
%
% 3/23/15   dhb  Wrote it.
% 6/29/15 dhb   Fix way we set up coneP to be more robust REPLACE_WITH_DASH_DASH  old less robust code got broken
%               by some lower level change.

varargout = UnitTest.runValidationRun(@ValidationFunction, nargout, varargin);
end

function ValidationFunction(runTimeParams)

%% Clear, define, etc.
ieInit;

%% Hello
UnitTest.validationRecord('SIMPLE_MESSAGE', sprintf('%s',mfilename));
outputDir = sprintf('%s_Output',mfilename);
if (~exist(outputDir,'dir'))
    mkdir(outputDir);
end

%% Supress irritating warnings
warnS = warning('off','images:initSize:adjustingMag');
try
    
    %% Frozen noise, so that we can validate OK
    randomSeedValue = 26;
    rng(randomSeedValue);
    
    %% Figure parameters
    curDir = pwd;
    masterFigParamsDir = getpref('bfScripts','masterFigParamsDir');
    cd(masterFigParamsDir);
    figParams = MasterFigParams;
    cd(curDir);
    if (exist('../SecondaryFigParams','file'))
        cd ..
        figParams = SecondaryFigParams(figParams);
        cd(curDir);
    end
    figParams.resizeScale = 1;
    UnitTest.validationData('figParams', figParams);
    
    %% Compute parameters
    %
    % You can set these to do whatever you feel like
    if (runTimeParams.inStandAloneMode)
        EXTRA_CHECKS = 1;
        sceneDegrees = 3;
        extractDegrees = 1;
        DELTAFCNOPTICS = 1;
        SONLY = 1;
        gratingCpd = 12;
        desiredSContrast = 0.75;
        SCALESRGBMethod = 1;
        % This branch is executed when you run from a validation script, and
        % should be left alone so that the parameters at runtime match those used
        % when the validation data were stored.
    else
        EXTRA_CHECKS = 1;
        sceneDegrees = 3;
        extractDegrees = 1;
        DELTAFCNOPTICS = 1;
        SONLY = 1;
        gratingCpd = 12;
        desiredSContrast = 0.75;
        SCALESRGBMethod = 1;
    end
    
    %% Set up output names
    if (DELTAFCNOPTICS)
        opticsStr = 'noblur';
    else
        opticsStr = 'blur';
    end
    if (SONLY)
        sConeStr = ['sConeMod_' num2str(round(100*desiredSContrast))];
    else
        sConeStr = 'achromMod';
    end
    outputSuffix = sprintf('_%dcpd_%s_%s',gratingCpd,opticsStr,sConeStr);
    
    %% Color matching functions
    S = [400 10 31];
    wls = SToWls(S);
    load('T_xyz1931');
    T_xyz = SplineCmf(S_xyz1931,T_xyz1931,S);
    UnitTest.validationData('S', S);
    UnitTest.validationData('T_xyz', T_xyz);
    
    %% Set up optical image
    %
    % Do this early so we have the OTF when we need it.
    oi = oiCreate('human');
    oi = opticsSet(oi,'off axis method','skip');
    
    % Allow delta function optics
    if (DELTAFCNOPTICS)
        %oi = oiSet(oi,'optics model','skip');
        % Kluge below, using 'skip seems cleaner
        %
        % Replace OTF with ones to get delta function optics
        % But, it seems to work just right.
        optics = oiGet(oi,'optics');
        OTFData = opticsGet(optics,'otfdata');
        OTFDeltaData = ones(size(OTFData));
        optics = opticsSet(optics,'otfdata',OTFDeltaData);
        oi = oiSet(oi,'optics',optics);
    end
    
    %% Set up sensor
    %
    % Do this early to get cone spectral sensitivities
    %
    % The isetbio cone default is for 200 linear cones per degree in the fovea.
    % This seems high for the central 1 degree overall, but might be correct
    % right at the center.  So we adjust via pixel size.
    %
    % For convenience, we normalize the energy unit fundamentals to a max of 1.
    % This is because we aren't going to try to get the units right in the
    % inverse transform from isomerization to XYZ, below.
    coneP = coneCreate('human');
    coneP = coneSet(coneP,'spatial density',[0.0 0.625 0.325 .05]);
    sensor = sensorCreate('human',[],coneP);
    sensor = sensorSet(sensor, 'noise flag', 0);
    sensor = sensorSet(sensor,'exp time',0.050);
    sensor = sensorSet(sensor,'rows',128);
    sensor = sensorSet(sensor,'cols',128);
    pixel = sensorGet(sensor,'pixel');
    pixel = pixelSet(pixel,'sizesamefillfactor',(200/120)*[1.5e-6 1.5e-6]);
    sensor = sensorSet(sensor,'pixel',pixel);
    T_conesQE = sensorGet(sensor,'spectral qe')';
    T_conesQE = T_conesQE(2:4,:);
    T_cones = EnergyToQuanta(wls,T_conesQE')';
    T_cones = T_cones/max(T_cones(:));
    UnitTest.validationData('T_conesQE', T_conesQE);
    UnitTest.validationData('T_cones', T_cones);
    
    %% Create the scene
    %
    % Choices are:
    %   'harmonic'
    %
    % Code for reading in a hyperspectral image here is in draft 0 of this
    % code, but was removed from here just to keep things a bit simpler.
    sceneType = 'harmonic';
    switch (sceneType)
        
        case 'harmonic'
            % Nice simple sinusoid.
            parms.freq = round(gratingCpd*sceneDegrees); parms.contrast = 1; parms.ph = 0;
            parms.ang= 0; parms.row = 600; parms.col = 600; parms.GaborFlag=0;
            scene = sceneCreate('harmonic',parms);
            scene = sceneSet(scene,'wave',wls');
            scene = sceneSet(scene,'fov',sceneDegrees);
            
        otherwise
            error('Unknown scene type');
    end
    
    %% Optional.  Muck with photons to make a cone isolationg modulation.
    %
    % This is moderately straightforward if we don't worry about chromatic
    % aberration, but gets trikier if we do. See below for method.
    if (SONLY)
        % Get photon image from scene
        scenePhotonsInitial = sceneGet(scene,'photons');
        
        % Get mean level of the pattern, so that we can extract what
        % the modulation around this is.
        for w = 1:length(wls)
            temp = scenePhotonsInitial(:,:,w);
            backgroundSpectrum(w) = mean(temp(:));
        end
        backgroundSpectrum = backgroundSpectrum';
        
        % Define an identity basis and expresss the background with
        % respect to it
        B_primary = 3*max(backgroundSpectrum(:))*eye(S(3));
        backgroundPrimary = B_primary\backgroundSpectrum;
        
        % Use silent substitution toolbox machinery to find us a
        % spectral modulation that isolates the S cones.
        whichPrimariesToPin = [1 size(B_primary,1)];
        primaryHeadRoom = 0.05;
        ambientSpd = zeros(size(B_primary,2),1);
        maxPowerDiff = 10000*max(backgroundSpectrum(:));
        whichReceptorsToTarget = [3];
        whichReceptorsToIgnore = [];
        whichReceptorsToMinimize = [];
        modulationPrimary = ReceptorIsolate(T_conesQE,whichReceptorsToTarget, whichReceptorsToIgnore, whichReceptorsToMinimize, ...
            B_primary, backgroundPrimary, backgroundPrimary, whichPrimariesToPin,...
            primaryHeadRoom, maxPowerDiff, [], ambientSpd);
        
        % Check that we got a sensible modulation with desired properties
        backgroundReceptors = T_conesQE*(B_primary*backgroundPrimary + ambientSpd);
        modulationReceptors = T_conesQE*B_primary*(modulationPrimary - backgroundPrimary);
        contrastReceptors = modulationReceptors ./ backgroundReceptors;
        fprintf('Maximized contrasts\n');
        for n = 1:size(T_conesQE,1)
            fprintf('\tPre-blur unmodified spectra, cone class %d contrast = %0.4f\n',n,contrastReceptors(n));
        end
        modSpecFig = figure; clf; hold on
        plot(wls,modulationPrimary,'r');
        plot(wls,backgroundPrimary,'k');
        ylim([0 1]);
        
        % Muck with the photons in the scene to make it the desired
        % spectral modulation.  We also adjust maximized contrast here
        % to give desired contrast.
        modulationSpectrum = B_primary*(modulationPrimary - backgroundPrimary);
        modulationSpectrum = (desiredSContrast/contrastReceptors(3))*modulationSpectrum;
        modulationReceptors = T_conesQE*modulationSpectrum;
        contrastReceptors = modulationReceptors ./ backgroundReceptors;
        fprintf('After contrast adjust\n');
        for n = 1:size(T_conesQE,1)
            fprintf('\tPre-blur unmodified spectra, cone class %d contrast = %0.4f\n',n,contrastReceptors(n));
        end
        scenePhotons = zeros(size(scenePhotonsInitial));
        for w = 1:length(wls)
            temp = scenePhotonsInitial(:,:,w);
            imageMean = mean(temp(:));
            modulation = temp-imageMean;
            modulation = modulation/max(modulation(:));
            modulation = modulation*modulationSpectrum(w);
            temp = imageMean+modulation;
            scenePhotons(:,:,w) = temp;
        end
        scene = sceneSet(scene,'photons',scenePhotons);
        minPhotons = min(scenePhotons(:));
        maxPhotons = max(scenePhotons(:));
        fprintf('Scene, min/max photons: %0.2g, %0.2g\n',minPhotons,maxPhotons);
    end
    
    %% Look at scene
    vcAddAndSelectObject(scene); sceneWindow;
    
    %% Render the scene as sRGB
    tempHyperspectralQuantal = scene.data.photons;
    [mScene,nScene,~] = size(tempHyperspectralQuantal);
    rowBorderScene = round((mScene - mScene*extractDegrees/sceneDegrees)/2);
    colBorderScene = round((nScene - nScene*extractDegrees/sceneDegrees)/2);
    tempHyperspectralEnergy = zeros(size(tempHyperspectralQuantal));
    for w = 1:length(wls)
        temp = tempHyperspectralQuantal(:,:,w);
        temp = temp(:);
        tempQuantal = QuantaToEnergy(wls(w),temp);
        tempHyperspectralEnergy(:,:,w) = reshape(tempQuantal,mScene,nScene);
    end
    sensorXYZImage = zeros(mScene,nScene,3);
    for i = 1:length(wls)
        sensorXYZImage(:,:,1) = sensorXYZImage(:,:,1) + T_xyz(1,i)*tempHyperspectralEnergy(:,:,i);
        sensorXYZImage(:,:,2) = sensorXYZImage(:,:,2) + T_xyz(2,i)*tempHyperspectralEnergy(:,:,i);
        sensorXYZImage(:,:,3) = sensorXYZImage(:,:,3) + T_xyz(3,i)*tempHyperspectralEnergy(:,:,i);
    end
    [sceneXYZCal,nX,nY] = ImageToCalFormat(sensorXYZImage);
    sceneXYZCal = sceneXYZCal/max(sceneXYZCal(:));
    srgbPrimaryCal = XYZToSRGBPrimary(sceneXYZCal);
    sRGBMeanScaleFactor = nanmean(srgbPrimaryCal(:));
    sRGBCal = SRGBGammaCorrect(0.5*srgbPrimaryCal/sRGBMeanScaleFactor,0);
    sceneSRGBImage = uint8(CalFormatToImage(sRGBCal,nX,nY));
    figure; clf;
    imshow(sceneSRGBImage);
    imwrite(sceneSRGBImage(rowBorderScene:end-rowBorderScene,colBorderScene:end-colBorderScene,:),fullfile(outputDir,[mfilename '_' 'sRGBScene' outputSuffix '.' figParams.imType]),figParams.imType);
    UnitTest.validationData('sceneSRBImage', sceneSRGBImage);
    
    %% Compute optical image
    oi = oiCompute(oi,scene);
    tempHyperspectralQuantal = oiGet(oi,'photons');
    [mOi,nOi,~] = size(tempHyperspectralQuantal);
    
    %% Compare actual and desired spectral modulations
    % Fix up as necessary.  This step is necessary for
    % the S-cone isolating modulation, because we want
    % it to be S-cone isolating on the retina, and chromatic
    % aberration will modify the initially presented stimulus.
    %
    % This counts on the fact that we have a grating stimulus, so
    % that the effect of blurring is more or less the same at all
    % pixels up to a scale factor.
    %
    % I also tried handling this by using the OTF directly, but it
    % didn't work very well.  It may be that I didn't fully debug
    % things, but I suspect that comptuational splatter was screwing
    % me up REPLACE_WITH_DASH_DASH given the frequency sampling, an arbitrary frequency
    % grating will not have its power all at one sf in the frequency
    % domain and that makes things a bit tricky.
    if (SONLY)
        for w = 1:length(wls)
            temp = tempHyperspectralQuantal(:,:,w);
            backgroundSpectrumActual(w) = mean(temp(:));
        end
        backgroundSpectrumActual = backgroundSpectrumActual';
        pixelSpectrumActual = squeeze(tempHyperspectralQuantal(round(mOi/2),round(nOi/2),:));
        modulationSpectrumActual = pixelSpectrumActual-backgroundSpectrumActual;
        modulationSpectrumCompare = modulationSpectrum*(modulationSpectrum\modulationSpectrumActual);
        figure; hold on
        plot(wls,backgroundSpectrumActual,'k');
        plot(wls,modulationSpectrumCompare+backgroundSpectrumActual,'r','LineWidth',2);
        plot(wls,modulationSpectrumActual+backgroundSpectrumActual,'g');
        
        % Fix up relative modulation spectrum
        %
        % First get OTF, dealing with the divide by zero problem
        index = find(modulationSpectrum ~= 0);
        effectiveOTFRelative = zeros(size(modulationSpectrum));
        effectiveOTFRelative(index) = modulationSpectrumActual(index) ./ modulationSpectrumCompare(index);
        index1 = find(modulationSpectrum == 0);
        effectiveOTFRelative(index1) = mean(effectiveOTFRelative(index));
        
        % Precompensate modulation spectrum and scale to match
        % original scene modulation
        newModulationSpectrumRelative = modulationSpectrum ./ effectiveOTFRelative;
        newModulationSpectrum = newModulationSpectrumRelative*(newModulationSpectrumRelative\modulationSpectrum);
        figure; clf; hold on
        plot(wls,backgroundSpectrum,'k');
        plot(wls,modulationSpectrum+backgroundSpectrum,'r');
        plot(wls,newModulationSpectrum+backgroundSpectrum,'g');
        
        % Report the cone contrasts pre blur for this modified spectrum, just
        % as a reality check.
        backgroundReceptors = T_conesQE*backgroundSpectrum;
        modulationReceptors = T_conesQE*newModulationSpectrum;
        contrastReceptors = modulationReceptors ./ backgroundReceptors;
        fprintf('Contrasts for modified spectra\n');
        for n = 1:size(T_conesQE,1)
            fprintf('\tPre-blur modified spectra, cone class %d contrast = %0.4f\n',n,contrastReceptors(n));
        end
        
        % Rewrite the scene with new modulation
        newScenePhotons = zeros(size(scenePhotonsInitial));
        for w = 1:length(wls)
            temp = scenePhotonsInitial(:,:,w);
            imageMean = mean(temp(:));
            modulation = temp-imageMean;
            modulation = modulation/max(modulation(:));
            modulation = modulation*newModulationSpectrum(w);
            temp = imageMean+modulation;
            newScenePhotons(:,:,w) = temp;
        end
        scene = sceneSet(scene,'photons',newScenePhotons);
        vcAddAndSelectObject(scene); sceneWindow;
        
        % Check
        newMinPhotons = min(newScenePhotons(:));
        newMaxPhotons = max(newScenePhotons(:));
        fprintf('Modified scene, min/max photons: %0.2g, %0.2g\n',newMinPhotons,newMaxPhotons);
        
        % Recompute the optical image and hope for the best
        oi = oiCompute(oi,scene);
    end
    vcAddAndSelectObject(oi); oiWindow;
    UnitTest.validationData('scene', scene);
    UnitTest.validationData('oi', oi);
    
    %% Render the oi as sRGB
    rowExtraBorderOi = round((mOi-mScene)/2);
    colExtraBorderOI = round((nOi-nScene)/2);
    tempHyperspectralEnergy = zeros(size(tempHyperspectralQuantal));
    for w = 1:length(wls)
        temp = tempHyperspectralQuantal(:,:,w);
        temp = temp(:);
        tempQuantal = QuantaToEnergy(wls(w),temp);
        tempHyperspectralEnergy(:,:,w) = reshape(tempQuantal,mOi,nOi);
    end
    oiXYZImage = zeros(mOi,nOi,3);
    for i = 1:length(wls)
        oiXYZImage(:,:,1) = oiXYZImage(:,:,1) + T_xyz(1,i)*tempHyperspectralEnergy(:,:,i);
        oiXYZImage(:,:,2) = oiXYZImage(:,:,2) + T_xyz(2,i)*tempHyperspectralEnergy(:,:,i);
        oiXYZImage(:,:,3) = oiXYZImage(:,:,3) + T_xyz(3,i)*tempHyperspectralEnergy(:,:,i);
    end
    [oiXYZCal,nX,nY] = ImageToCalFormat(oiXYZImage);
    oiXYZCal = oiXYZCal/max(oiXYZCal(:));
    srgbPrimaryCal = XYZToSRGBPrimary(oiXYZCal);
    sRGBMeanScaleFactor = nanmean(srgbPrimaryCal(:));
    sRGBCal = SRGBGammaCorrect(0.5*srgbPrimaryCal/sRGBMeanScaleFactor,0);
    oiSRGBImage = uint8(CalFormatToImage(sRGBCal,nX,nY));
    figure; clf;
    imshow(oiSRGBImage);
    imwrite(oiSRGBImage(rowExtraBorderOi+rowBorderScene:end-rowBorderScene-rowExtraBorderOi,colExtraBorderOI+colBorderScene:end-colBorderScene-colExtraBorderOI,:), ...
        fullfile(outputDir,[mfilename '_' 'sRGBOptics' outputSuffix '.' figParams.imType]),figParams.imType);
    UnitTest.validationData('oiSRGBImage', oiSRGBImage);
    
    %% Make sensor image
    [sensor, ~] = sensorSetSizeToFOV(sensor,sceneDegrees,scene,oi);
    sensor = sensorCompute(sensor,oi);
    vcAddAndSelectObject(sensor); sensorWindow('scale',1);
    UnitTest.validationData('sensor', sensor);
    
    %% Demosaic
    cfa = sensorGet(sensor,'cfa');
    mosaicImage = sensorGet(sensor,'photons');
    [imageHeight,imageWidth] = size(mosaicImage);
    
    % Use griddata to do separate submosaic interpolation
    %
    % Be sure to deal with isetbio's indexing that 1 -> black.
    method = 'linear';
    [X,Y] = meshgrid(1:imageWidth,1:imageHeight);
    nCones = zeros(size(T_conesQE,1),1);
    for n = 1:size(T_conesQE,1)
        index = find(cfa.pattern == n+1);
        nCones(n) = length(index(:));
        x1 = X(index);
        y1 = Y(index);
        z1 = mosaicImage(index);
        interpImageLMS(:,:,n) = griddata(x1,y1,z1,X,Y,method);
        fprintf('Cone class %d, min = %0.2g, max = %0.2g\n',n,min(z1(:)),max(z1(:)));
    end
    for n = 1:size(T_conesQE,1)
        fprintf('Fraction cone class %d = %0.2f\n',n,nCones(n)/sum(nCones));
    end
    fprintf('Total number of cones %d, expected %d\n',sum(nCones),imageWidth*imageHeight);
    UnitTest.assertIsZero(sum(nCones)-imageWidth*imageHeight,'Difference from expected total number of cones',0);
    UnitTest.validationData('interpImageLMS', interpImageLMS);
    
    % Just checking.  T_cones ought to be proportional to T_cones_ss2, more or
    % less.  It is.  The small differenes are due to slightly different
    % tabulations of the Stockman-Sharpe fundamentals in PTB and ISETBIO.
    if (EXTRA_CHECKS)
        load T_cones_ss2
        figure; clf; hold on
        plot(wls,T_cones','r');
        plot(wls,T_cones(1,:)'/max(T_cones(1,:)),'b');
        plot(wls,T_cones(2,:)'/max(T_cones(2,:)),'b');
        plot(wls,T_cones(3,:)'/max(T_cones(3,:)),'b');
        plot(SToWls(S_cones_ss2),T_cones_ss2','g');
        xlabel('Wavelength (nm)');
        ylabel('Sensitivity (energy units)');
        title('Check on cone sensitivities');
        clear T_cones_ss2 S_cones_ss2
    end
    
    % Render by converting from LMS to sRGB.
    %
    % Start by finding matrix that takes LMS to XYZ.  We use
    % T_cones in the conversion, because T_cones is in energy
    % units but scaled consistently with the quantal efficiencies
    % used to compute the isomerizations.
    %
    % The absolute units here are not correct, because we'd have to
    % back from isomerization out to cd/m2 in order to get them correct,
    % and that would be a pain.
    M_LMSToXYZ = ((T_cones)'\(T_xyz'))';
    if (EXTRA_CHECKS)
        T_xyzCheck = M_LMSToXYZ*T_cones;
        figure; clf; hold on
        plot(wls,T_xyz','k');
        plot(wls,T_xyzCheck','r');
        xlabel('Wavelength (nm)');
        ylabel('XYZ');
        title('LMS -> XYZ Check');
    end
    
    % Here are the xform matrices that sensorDemosaicCones is using,
    % transposed for PTB format.
    if (EXTRA_CHECKS)
        M_lms2xyz = [1.7896   -1.4694    2.1504
            0.6079    0.4651   -0.2236
            -0.0499    0.0923   10.6431];
        M_xyz2srgb = [3.2410   -1.5374   -0.4986
            -0.9692    1.8760    0.0416
            0.0556   -0.2040    1.0570];
    end
    
    % The exact order of clipping and scaling in the conversion from
    % XYZ to sRGB matters in some cases.  ISETBIO scales in XYZ by
    % the maximum Y value, then clips negative XYZ values, then converts
    % to SRGB primaries, and then clips to 0-1.  PTB does not touch the
    % XYZ values normally, and can either scale to max of 1 in SRGB primary
    % or clip, depending on how you call SRGBGammaCorrect.  Here I have
    % made the PTB behavior match the ISETBIO behavior by hand, depending on
    % the value of SCALESRGBMethod.
    if (EXTRA_CHECKS)
        [interpImageLMSCal,m,n] = ImageToCalFormat(interpImageLMS);
        interpImageXYZCal = M_LMSToXYZ*interpImageLMSCal;
        interpImageXYZCalCheck = M_lms2xyz*interpImageLMSCal;
        interpImageXYZCal = interpImageXYZCal/max(interpImageXYZCal(2,:));
        interpImageXYZCalCheck = interpImageXYZCalCheck/max(interpImageXYZCalCheck(2,:));
        if (~SCALESRGBMethod)
            interpImageXYZCal(interpImageXYZCal < 0) = 0;
            interpImageXYZCalCheck(interpImageXYZCalCheck < 0) = 0;
        end
        interpImageSRGBPrimaryCal = XYZToSRGBPrimary(interpImageXYZCal);
        interpImageSRGBPrimaryCalCheck = M_xyz2srgb*interpImageXYZCal;
        if (SCALESRGBMethod)
            sRGBMeanScaleFactor = nanmean(interpImageSRGBPrimaryCal(:));
            interpImageSRGBCal = SRGBGammaCorrect(0.5*interpImageSRGBPrimaryCal/sRGBMeanScaleFactor,0);
        else
            interpImageSRGBCal = SRGBGammaCorrect(interpImageSRGBPrimaryCal,0);
        end
        interpImageSRGB = uint8(CalFormatToImage(interpImageSRGBCal,m,n));
        UnitTest.validationData('interpImageSRGB', interpImageSRGB);
    end
    
    % This figure checks for consistency between two ways of computing some of
    % the relevant quantities
    if (EXTRA_CHECKS)
        figure; clf;
        subplot(1,2,1); hold on
        plot(interpImageXYZCal(:),interpImageXYZCalCheck(:),'ro');
        plot([0 1],[0 1],'k');
        xlabel('XYZ convert PTB');
        ylabel('XYZ convert isetbio matrix');
        subplot(1,2,2); hold on
        plot(interpImageSRGBPrimaryCal(:),interpImageSRGBPrimaryCalCheck(:),'ro');
        plot([-0.5 1.5],[-0.5 1.5],'k');
        axis([-0.5 1.5 -0.5 1.5]);
        xlabel('sRGBPrimary convert PTB');
        ylabel('sRGBPrimary convert isetbio matrix');
    end
    
    %% Isetbio cone demosaicing
    %
    % That's the way you do, get your money for nothing.
    [isetbioInterpImageSRGB,isetbioInterpImageLMS] = sensorDemosaicCones(sensor,method);
    UnitTest.validationData('isetbioInterpImageLMS', isetbioInterpImageLMS);
    UnitTest.validationData('isetbioInterpImageSRGB', isetbioInterpImageSRGB);
    
    % We can do the PTB SRGB method, which works better if there is masssive
    % ringing.
    [mInterp,nInterp,~] = size(isetbioInterpImageSRGB);
    rowBorderInterp = round((mInterp-mInterp*extractDegrees/sceneDegrees)/2);
    colBorderInterp = round((nInterp-nInterp*extractDegrees/sceneDegrees)/2);
    figure; clf;
    if (EXTRA_CHECKS & SCALESRGBMethod)
        imshow(interpImageSRGB);
        title('Linear interp SRGB');
        imwrite(interpImageSRGB(rowBorderInterp:end-rowBorderInterp,colBorderInterp:end-colBorderInterp,:),fullfile(outputDir,[mfilename '_' 'sRGBInterp' outputSuffix '.' figParams.imType]),figParams.imType);
    else
        imshow(isetbioInterpImageSRGB);
        title('Linear interp SRGB');
        imwrite(isetbioInterpImageSRGB(rowBorderInterp:end-rowBorderInterp,colBorderInterp:end-colBorderInterp,:),fullfile(outputDir,[mfilename '_' 'sRGBInterp' outputSuffix '.' figParams.imType]),figParams.imType);
    end
    
    % Compare with the local way
    if (EXTRA_CHECKS)
        figure; clf;
        subplot(1,2,1); hold on;
        imshow(interpImageSRGB(rowBorderInterp:end-rowBorderInterp,colBorderInterp:end-colBorderInterp,:));
        title('Local linear interp SRGB');
        subplot(1,2,2); hold on;
        imshow(isetbioInterpImageSRGB(rowBorderInterp:end-rowBorderInterp,colBorderInterp:end-colBorderInterp,:));
        title('ISETBIO linear interp SRGB');
        differenceInterpLMS = interpImageLMS(:) - isetbioInterpImageLMS(:);
        maxDifferenceLMS = max(abs(differenceInterpLMS));
        tolerance = 1e-17;
        UnitTest.assertIsZero(maxDifferenceLMS,'ISETBIO and local griddata difference',tolerance);
    end
    
    %% Freeman method demosaicing
    %
    % I implemented this by and and then in ISETBIO
    if (EXTRA_CHECKS)
        masterSensor = 1;
        filterSize = 5;
        freemanInterpImageLMS = interpImageLMS;
        tempMaster = interpImageLMS(:,:,masterSensor);
        for n = 1:3
            if (n ~= masterSensor)
                diffImage = interpImageLMS(:,:,n) - tempMaster;
                diffImage = medfilt2(diffImage,[filterSize filterSize]);
                index = find(cfa.pattern ~= n+1);
                temp = interpImageLMS(:,:,n);
                temp(index) = diffImage(index) + tempMaster(index);
                freemanInterpImageLMS(:,:,n) = temp;
            end
        end
        
        [freemanInterpImageLMSCal,m,n] = ImageToCalFormat(freemanInterpImageLMS);
        freemanInterpImageXYZCal = M_LMSToXYZ*freemanInterpImageLMSCal;
        freemanInterpImageXYZCal = freemanInterpImageXYZCal/max(freemanInterpImageXYZCal(2,:));
        if (~SCALESRGBMethod)
            freemanInterpImageXYZCal(freemanImageXYZCal < 0) = 0;
        end
        freemanInterpImageSRGBPrimayCal = XYZToSRGBPrimary(freemanInterpImageXYZCal);
        if (SCALESRGBMethod)
            sRGBMeanScaleFactor = nanmean(freemanInterpImageSRGBPrimayCal(:));
            freemanInterpImageSRGBCal = SRGBGammaCorrect(0.5*interpImageSRGBPrimaryCal/sRGBMeanScaleFactor,0);
        else
            freemanInterpImageSRGBCal = SRGBGammaCorrect(freemanInterpImageSRGBPrimayCal,0);
        end
        freemanInterpImageSRGB = uint8(CalFormatToImage(freemanInterpImageSRGBCal,m,n));
        UnitTest.validationData('freemanInterpImageLMS', freemanInterpImageLMS);
        UnitTest.validationData('freemanInterpImageSRGB', freemanInterpImageSRGB);
    end
    
    % Now just do it in ISETBIO
    [isetbioFreemanInterpImageSRGB,isetbioFreemanInterpImageLMS] = sensorDemosaicCones(sensor,'freeman');
    figure; clf;
    if (EXTRA_CHECKS & SCALESRGBMethod)
        imshow(freemanInterpImageSRGB);
        title('Freeman interp SRGB');
        imwrite(freemanInterpImageSRGB(rowBorderInterp:end-rowBorderInterp,colBorderInterp:end-colBorderInterp,:),fullfile(outputDir,[mfilename '_' 'sRGBFreemanInterp' outputSuffix '.' figParams.imType]),figParams.imType);
    else
        imshow(isetbioFreemanInterpImageSRGB);
        title('Freeman interp SRGB');
        [mInterp,nInterp,~] = size(isetbioFreemanInterpImageSRGB);
        imwrite(isetbioFreemanInterpImageSRGB(rowBorderInterp:end-rowBorderInterp,colBorderInterp:end-colBorderInterp,:),fullfile(outputDir,[mfilename '_' 'sRGBFreemanInterp' outputSuffix '.' figParams.imType]),figParams.imType);
    end
    UnitTest.validationData('isetbioFreemanInterpImageLMS', isetbioFreemanInterpImageLMS);
    UnitTest.validationData('isetbioFreemanInterpImageSRGB', isetbioFreemanInterpImageSRGB);
    
    % Compare with the local way
    if (EXTRA_CHECKS)
        figure; clf;
        subplot(1,2,1); hold on;
        imshow(isetbioFreemanInterpImageSRGB(rowBorderInterp:end-rowBorderInterp,colBorderInterp:end-colBorderInterp,:));
        title('Local Freeman interp SRGB');
        subplot(1,2,2); hold on;
        imshow(isetbioFreemanInterpImageSRGB(rowBorderInterp:end-rowBorderInterp,colBorderInterp:end-colBorderInterp,:));
        title('ISETBIO Freeman interp SRGB');
        differenceFreemanLMS = interpImageLMS(:) - isetbioInterpImageLMS(:);
        maxDifferenceLMS = max(abs(differenceFreemanLMS));
        if (maxDifferenceLMS ~= 0)
            fprintf('WARNING: ISETBIO and local freeman interpolation do not agree\n');
        end
    end
    
catch err
    %% Restore warning state
    warning(warnS.state,warnS.identifier);
    
    %% Rethrow error
    rethrow(err);
end

end

##### SOURCE END #####
--></body></html>