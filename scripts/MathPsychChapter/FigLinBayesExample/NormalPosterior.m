function [u,K] = NormalPosterior(data,prioru,priorK,R,noiseK)% Evaluate the posterior for multivariate normal prior, linear/normal likelihood %% Syntax:%     [u,K] = NormalPosterior(data,prioru,priorK,R,noiseK)%% Description:%     Given a multivariate Normal prior and multivariate Normal likelihood,%     the posterior is Normal and its mean and covariance matrix are%     relatively easily computed.  This routine does the computation for%     the case where the noise free observation is a linear function of the%     state variable being estimated.%%     Here the noise is assumed to be zero mean, but can have a covariance%     structure.%%     That is given:%        p(x) = N(priorU, priorK)%        p(y | x) = N(R*x, noiseK)%% Inputs:%     data       - Column vector with the multivariate observation.%     prioru     - Column vector with mean of the prior%     priorK     - Prior covariance matrix%     R          - Matrix mapping state vector x to mean observation y%     noiseK     - Covariancer matrix of the zero mean Normal noise.%% Outputs:%     u          - Column vector containg mean of posterior, which in turn %                  is a good point estimate.%     K          - Covariance matrix for the posterior.% History:%   07/12/21   dhb  Added header comment, as well as checking that two%                   ways to do the computation give the same answer.% This formula derived in Brainard notes, 9/17/92invnoiseK = inv(noiseK);invpriorK = inv(priorK);factor1 = R'*invnoiseK*R;factor2 = inv(invpriorK + factor1);W = factor2*R'*invnoiseK;b = factor2*invpriorK*prioru;u = W*data+b;% This is how I read the same notes in 2021.% The answer comes out the same.M = priorK*R'*inv(R*priorK*R' + noiseK);u1 = M*data + prioru - M*R*prioru; if (max(abs(u-u1)) > 1e-8)    error('Two ways of computing the prior do not agree');end% Covariance matrix of posteriorK = inv(invpriorK + R'*invnoiseK*R);