function [u,K] = NormalPosterior(data,prioru,priorK,R,noiseK)% Evaluate the posterior for multivariate normal prior, linear/normal likelihood %% Syntax:%     [u,K] = NormalPosterior(data,prioru,priorK,R,noiseK)%% Description:%     Given a multivariate Normal prior and multivariate Normal likelihood,%     the posterior is Normal and its mean and covariance matrix are%     relatively easily computed.  This routine does the computation for%     the case where the noise free observation is a linear function of the%     state variable being estimated.%%     Here the noise is assumed to be zero mean, but can have a covariance%     structure.%%     That is given:%        p(x) = N(priorU, priorK)%        p(y | x) = N(R*x, noiseK)%     compute u and K such that:%        p(x | y) = N(u, K)%%     The derivation is in Brainard, D. H. (1995). "An Ideal Observer for%     Appearance: Reconstruction from Samples," UCSB Vision Labs Tech%     Report 95-1, Department of Psychology, UC Santa Barbara, Santa%     Barbara, CA.%     http://color.psych.upenn.edu/brainard/papers/bayessampling.pdf.%% Inputs:%     data       - Column vector with the multivariate observation.%     prioru     - Column vector with mean of the prior%     priorK     - Prior covariance matrix%     R          - Matrix mapping state vector x to mean observation y%     noiseK     - Covariancer matrix of the zero mean Normal noise.%% Outputs:%     u          - Column vector containg mean of posterior, which in turn %                  is a good point estimate.%     K          - Covariance matrix for the posterior.% History:%   07/12/21   dhb  Added header comment, as well as checking that two%                   ways to do the computation give the same answer.% This formula derived in Brainard notes, 9/17/92% This is form Equation A-3, with%   K -> factor2%   u_e -> 0invnoiseK = inv(noiseK);invpriorK = inv(priorK);factor1 = R'*invnoiseK*R;factor2 = inv(invpriorK + factor1);W = factor2*R'*invnoiseK;b = factor2*invpriorK*prioru;u = W*data+b;% This is Equations 10 and 11 in the notes,% with:%   S -> R%   u_e -> 0%   u_w -> prioru%   I -> M as computed here%   i0 -> added explicitly to u1.% These are the result of simplifying A-3, I'm% pretty sure.%% The answer comes out the same as the above, which% is reassuring.M = priorK*R'*inv(R*priorK*R' + noiseK);u1 = M*data + prioru - M*R*prioru; if (max(abs(u-u1)) > 1e-8)    error('Two ways of computing the prior do not agree');end% Covariance matrix of posterior.  Equation A-3.K = inv(invpriorK + R'*invnoiseK*R);